const { Evidence, Challenge, User, sequelize, TimelineEvent } = require('../models');
const notificationController = require('./notificationController');

// Crear una nueva evidencia (sin archivo)
exports.createEvidence = async (req, res) => {
  console.log('üöÄ [createEvidence] INICIO - Funci√≥n createEvidence llamada');
  console.log('üöÄ [createEvidence] M√©todo:', req.method);
  console.log('üöÄ [createEvidence] URL:', req.originalUrl);
  console.log('üöÄ [createEvidence] Params:', req.params);
  console.log('üöÄ [createEvidence] Body:', req.body);
  
  const transaction = await sequelize.transaction();
  
  try {
    // Aceptar tanto challengeId como id para compatibilidad con diferentes rutas
    const challengeId = req.params.challengeId || req.params.id;
    const { description, fileUrl, fileType } = req.body;
    const userId = req.user.id;
    
    console.log(`üì§ [createEvidence] Creando evidencia para desaf√≠o ${challengeId} por usuario ${userId}`);
    console.log(`üì§ [createEvidence] Datos recibidos:`, { description, fileUrl, fileType });

    // Verificar que el desaf√≠o existe
    const challenge = await Challenge.findByPk(challengeId);
    if (!challenge) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Desaf√≠o no encontrado'
      });
    }

    // Verificar que el usuario es participante del desaf√≠o
    const user = await User.findByPk(userId);
    if (!user) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Verificar que el desaf√≠o est√° en progreso
    if (challenge.status !== 'in_progress') {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Solo se pueden a√±adir evidencias a desaf√≠os en progreso'
      });
    }

    // Crear la evidencia (sin archivo)
    const evidence = await Evidence.create({
      challengeId,
      userId,
      description: description || 'Evidencia de texto',
      fileUrl: null, // No hay archivo
      fileType: 'text/plain', // Tipo por defecto para evidencias de texto
      timestamp: new Date(),
      status: 'pending'
    }, { transaction });

    console.log(`‚úÖ [createEvidence] Evidencia creada con ID: ${evidence.id}`);

    // Crear evento de timeline para la evidencia enviada
    const timelineEvent = await TimelineEvent.create({
      challengeId,
      type: 'evidence_submitted',
      description: `${user.fullName} (${user.username}) subi√≥ nueva evidencia: ${description || 'Sin descripci√≥n'}`,
      timestamp: new Date()
    }, { transaction });

    console.log(`üìã [createEvidence] Evento de timeline creado: ${timelineEvent.id}`);

    // Determinar qui√©n es el oponente para enviar notificaci√≥n
    let opponentId;
    if (challenge.creatorId === userId) {
      opponentId = challenge.challengerId;
    } else {
      opponentId = challenge.creatorId;
    }

    // Enviar notificaci√≥n al oponente
    if (opponentId) {
      try {
        await notificationController.createNotification({
          userId: opponentId,
          type: 'evidence_submitted',
          title: 'Nueva evidencia subida',
          message: `${user.fullName} (${user.username}) ha subido una nueva evidencia en el desaf√≠o "${challenge.title}"`,
          relatedId: challengeId,
          relatedType: 'challenge'
        });
        console.log(`üîî [createEvidence] Notificaci√≥n enviada al oponente: ${opponentId}`);
      } catch (notifError) {
        console.error('‚ö†Ô∏è [createEvidence] Error al enviar notificaci√≥n:', notifError);
      }
    }

    await transaction.commit();

    res.status(201).json({
      success: true,
      message: 'Evidencia creada con √©xito',
      data: evidence
    });
  } catch (error) {
    await transaction.rollback();
    console.error('‚ùå [createEvidence] Error al crear evidencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear la evidencia',
      error: error.message
    });
  }
};

// Crear evidencia con archivo subido
exports.createEvidenceWithFile = async (req, res) => {
  console.log('üöÄ [createEvidenceWithFile] INICIO - Funci√≥n createEvidenceWithFile llamada');
  console.log('üöÄ [createEvidenceWithFile] M√©todo:', req.method);
  console.log('üöÄ [createEvidenceWithFile] URL:', req.originalUrl);
  console.log('üöÄ [createEvidenceWithFile] Params:', req.params);
  console.log('üöÄ [createEvidenceWithFile] Body:', req.body);
  console.log('üöÄ [createEvidenceWithFile] Archivo:', req.evidenceFile);
  
  const transaction = await sequelize.transaction();
  
  try {
    // Aceptar tanto challengeId como id para compatibilidad con diferentes rutas
    const challengeId = req.params.challengeId || req.params.id;
    const { description } = req.body;
    const userId = req.user.id;
    
    console.log(`üì§ [createEvidenceWithFile] Creando evidencia con archivo para desaf√≠o ${challengeId} por usuario ${userId}`);
    console.log(`üì§ [createEvidenceWithFile] Descripci√≥n:`, description);
    console.log(`üì§ [createEvidenceWithFile] Archivo:`, req.evidenceFile);

    // Verificar que el desaf√≠o existe
    const challenge = await Challenge.findByPk(challengeId);
    if (!challenge) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Desaf√≠o no encontrado'
      });
    }

    // Verificar que el usuario es participante del desaf√≠o
    const user = await User.findByPk(userId);
    if (!user) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Verificar que el desaf√≠o permite subir evidencias
    const allowedStatuses = ['in_progress', 'judge_assigned'];
    if (!allowedStatuses.includes(challenge.status)) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: `Solo se pueden a√±adir evidencias a desaf√≠os en progreso o con juez asignado. Estado actual: ${challenge.status}`
      });
    }

    // Crear la evidencia con la informaci√≥n del archivo
    const evidence = await Evidence.create({
      challengeId,
      userId,
      description: description || 'Evidencia subida',
      fileUrl: req.evidenceFile.url,
      fileType: req.evidenceFile.mimetype,
      timestamp: new Date(),
      status: 'pending'
    }, { transaction });

    console.log(`‚úÖ [createEvidenceWithFile] Evidencia creada con ID: ${evidence.id}`);

    // Crear evento en el timeline
    const timelineEvent = await TimelineEvent.create({
      challengeId,
      type: 'evidence_submitted',
      description: `${user.fullName} (${user.username}) subi√≥ nueva evidencia: ${description || req.evidenceFile.originalname}`,
      timestamp: new Date()
    }, { transaction });

    console.log(`üìã [createEvidenceWithFile] Evento de timeline creado: ${timelineEvent.id}`);

    // Determinar qui√©n es el oponente para enviar notificaci√≥n
    let opponentId;
    if (challenge.creatorId === userId) {
      opponentId = challenge.challengerId;
    } else {
      opponentId = challenge.creatorId;
    }

    // Enviar notificaci√≥n al oponente
    if (opponentId) {
      try {
        await notificationController.createNotification({
          userId: opponentId,
          type: 'evidence_submitted',
          title: 'Nueva evidencia subida',
          message: `${user.fullName} (${user.username}) ha subido una nueva evidencia en el desaf√≠o "${challenge.title}"`,
          relatedId: challengeId,
          relatedType: 'challenge'
        });
        console.log(`üîî [createEvidenceWithFile] Notificaci√≥n enviada al oponente: ${opponentId}`);
      } catch (notifError) {
        console.error('‚ö†Ô∏è [createEvidenceWithFile] Error al enviar notificaci√≥n:', notifError);
      }
    }

    await transaction.commit();

    // Responder con la evidencia creada
    res.status(201).json({
      success: true,
      message: 'Evidencia subida exitosamente',
      data: {
        id: evidence.id,
        challengeId: evidence.challengeId,
        userId: evidence.userId,
        description: evidence.description,
        fileUrl: evidence.fileUrl,
        fileType: evidence.fileType,
        status: evidence.status,
        timestamp: evidence.timestamp,
        createdAt: evidence.createdAt,
        user: {
          id: user.id,
          username: user.username,
          fullName: user.fullName,
          profilePicture: user.profilePicture
        }
      }
    });

  } catch (error) {
    await transaction.rollback();
    console.error('‚ùå [createEvidenceWithFile] Error al crear evidencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear la evidencia',
      error: error.message
    });
  }
};

// Obtener todas las evidencias de un desaf√≠o
exports.getChallengeEvidences = async (req, res) => {
  try {
    // Aceptar tanto challengeId como id para compatibilidad con diferentes rutas
    const challengeId = req.params.challengeId || req.params.id;
    
    console.log(`üîç [getChallengeEvidences] Obteniendo evidencias para desaf√≠o: ${challengeId}`);

    // Primero intentar sin include para debuggear
    const evidences = await Evidence.findAll({
      where: { challengeId },
      order: [['createdAt', 'DESC']]
    });
    
    console.log(`üìä [getChallengeEvidences] Evidencias encontradas (sin include): ${evidences.length}`);
    
    // Si hay evidencias, intentar obtener los usuarios por separado
    const evidencesWithUsers = [];
    for (const evidence of evidences) {
      const user = await User.findByPk(evidence.userId, {
        attributes: ['id', 'username', 'fullName', 'profilePicture']
      });
      evidencesWithUsers.push({
        ...evidence.toJSON(),
        submitter: user
      });
    }

    console.log(`‚úÖ [getChallengeEvidences] Encontradas ${evidencesWithUsers.length} evidencias con usuarios`);

    res.json({
      success: true,
      data: evidencesWithUsers
    });
  } catch (error) {
    console.error('‚ùå [getChallengeEvidences] Error al obtener evidencias:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener las evidencias',
      error: error.message
    });
  }
};

// Obtener una evidencia espec√≠fica
exports.getEvidenceById = async (req, res) => {
  try {
    const { evidenceId } = req.params;

    const evidence = await Evidence.findByPk(evidenceId, {
      include: [
        {
          model: User,
          as: 'submitter',
          attributes: ['id', 'username', 'fullName', 'profilePicture']
        },
        {
          model: Challenge,
          attributes: ['id', 'title', 'status']
        }
      ]
    });

    if (!evidence) {
      return res.status(404).json({
        success: false,
        message: 'Evidencia no encontrada'
      });
    }

    res.json({
      success: true,
      data: evidence
    });
  } catch (error) {
    console.error('Error al obtener evidencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener la evidencia',
      error: error.message
    });
  }
};

// Actualizar el estado de una evidencia (aprobar/rechazar)
exports.updateEvidenceStatus = async (req, res) => {
  console.log('‚úÖ [updateEvidenceStatus] INICIO - Funci√≥n updateEvidenceStatus llamada');
  console.log('‚úÖ [updateEvidenceStatus] M√©todo:', req.method);
  console.log('‚úÖ [updateEvidenceStatus] URL:', req.originalUrl);
  console.log('‚úÖ [updateEvidenceStatus] Params:', req.params);
  console.log('‚úÖ [updateEvidenceStatus] Body:', req.body);
  console.log('‚úÖ [updateEvidenceStatus] Usuario:', req.user?.id);
  
  const transaction = await sequelize.transaction();
  
  try {
    const { evidenceId } = req.params;
    const { status, judgeComments } = req.body;
    const userId = req.user.id;
    
    console.log(`‚úÖ [updateEvidenceStatus] Actualizando evidencia ${evidenceId} a estado ${status} por usuario ${userId}`);

    // Validar el estado
    if (!['approved', 'rejected'].includes(status)) {
      await transaction.rollback();
      return res.status(400).json({
        success: false,
        message: 'Estado inv√°lido. Debe ser "approved" o "rejected"'
      });
    }

    // Obtener la evidencia
    console.log('‚úÖ [updateEvidenceStatus] Buscando evidencia con ID:', evidenceId);
    const evidence = await Evidence.findByPk(evidenceId, {
      include: [
        {
          model: Challenge,
          as: 'challenge',
          include: [
            {
              model: User,
              as: 'creator',
              attributes: ['id', 'username', 'fullName']
            },
            {
              model: User,
              as: 'challengerUser',
              attributes: ['id', 'username', 'fullName']
            }
          ]
        },
        {
          model: User,
          as: 'user',
          attributes: ['id', 'username', 'fullName']
        }
      ]
    });
    
    console.log('‚úÖ [updateEvidenceStatus] Evidencia encontrada:', evidence ? 'S√ç' : 'NO');
    if (evidence) {
      console.log('‚úÖ [updateEvidenceStatus] Challenge ID:', evidence.challengeId);
      console.log('‚úÖ [updateEvidenceStatus] Judge ID del desaf√≠o:', evidence.challenge?.judgeId);
      console.log('‚úÖ [updateEvidenceStatus] Usuario actual:', userId);
      console.log('‚úÖ [updateEvidenceStatus] ¬øEs juez?:', evidence.challenge?.judgeId === userId);
    }

    if (!evidence) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Evidencia no encontrada'
      });
    }

    // Verificar que el usuario es el juez del desaf√≠o
    if (evidence.challenge.judgeId !== userId) {
      await transaction.rollback();
      return res.status(403).json({
        success: false,
        message: 'Solo el juez puede actualizar el estado de las evidencias'
      });
    }

    // Actualizar la evidencia
    await evidence.update({
      status,
      judgeComments
    }, { transaction });

    // Crear evento de timeline
    const user = await User.findByPk(userId);
    const statusText = status === 'approved' ? 'aprob√≥' : 'rechaz√≥';
    
    const timelineEvent = await TimelineEvent.create({
      challengeId: evidence.challengeId,
      type: `evidence_${status}`,
      description: `${user.fullName} (${user.username}) ${statusText} la evidencia de ${evidence.user.fullName}`,
      timestamp: new Date()
    }, { transaction });

    // Enviar notificaci√≥n al usuario que subi√≥ la evidencia
    try {
      await notificationController.createNotification({
        userId: evidence.userId,
        type: `evidence_${status}`,
        title: `Evidencia ${status === 'approved' ? 'aprobada' : 'rechazada'}`,
        message: `Tu evidencia ha sido ${status === 'approved' ? 'aprobada' : 'rechazada'} por el juez ${user.fullName}`,
        relatedId: evidence.challengeId,
        relatedType: 'challenge'
      });
      console.log(`üîî [updateEvidenceStatus] Notificaci√≥n enviada al usuario: ${evidence.userId}`);
    } catch (notifError) {
      console.error('‚ö†Ô∏è [updateEvidenceStatus] Error al enviar notificaci√≥n:', notifError);
    }

    await transaction.commit();

    res.json({
      success: true,
      message: `Evidencia ${status === 'approved' ? 'aprobada' : 'rechazada'} con √©xito`,
      data: evidence
    });
  } catch (error) {
    await transaction.rollback();
    console.error('Error al actualizar estado de evidencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar el estado de la evidencia',
      error: error.message
    });
  }
};

// Eliminar una evidencia
exports.deleteEvidence = async (req, res) => {
  console.log('üóëÔ∏è [deleteEvidence] INICIO - Funci√≥n deleteEvidence llamada');
  console.log('üóëÔ∏è [deleteEvidence] M√©todo:', req.method);
  console.log('üóëÔ∏è [deleteEvidence] URL:', req.originalUrl);
  console.log('üóëÔ∏è [deleteEvidence] Params:', req.params);
  console.log('üóëÔ∏è [deleteEvidence] Usuario:', req.user?.id);
  
  const transaction = await sequelize.transaction();
  
  try {
    const { evidenceId } = req.params;
    const userId = req.user.id;
    
    console.log(`üóëÔ∏è [deleteEvidence] Intentando eliminar evidencia ${evidenceId} por usuario ${userId}`);

    const evidence = await Evidence.findByPk(evidenceId);
    console.log('üóëÔ∏è [deleteEvidence] Evidencia encontrada:', evidence ? 'S√ç' : 'NO');
    
    if (evidence) {
      console.log('üóëÔ∏è [deleteEvidence] Propietario de la evidencia:', evidence.userId);
      console.log('üóëÔ∏è [deleteEvidence] Usuario solicitante:', userId);
      console.log('üóëÔ∏è [deleteEvidence] ¬øEs propietario?:', evidence.userId === userId);
    }
    
    if (!evidence) {
      await transaction.rollback();
      return res.status(404).json({
        success: false,
        message: 'Evidencia no encontrada'
      });
    }

    // Verificar que el usuario es el propietario de la evidencia
    if (evidence.userId !== userId) {
      await transaction.rollback();
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar esta evidencia'
      });
    }

    console.log('üóëÔ∏è [deleteEvidence] Eliminando evidencia de la base de datos...');
    await evidence.destroy({ transaction });
    console.log('üóëÔ∏è [deleteEvidence] Evidencia eliminada, confirmando transacci√≥n...');
    await transaction.commit();
    console.log('üóëÔ∏è [deleteEvidence] Transacci√≥n confirmada exitosamente');

    res.json({
      success: true,
      message: 'Evidencia eliminada con √©xito'
    });
    
    console.log('üóëÔ∏è [deleteEvidence] Respuesta enviada al cliente');
  } catch (error) {
    await transaction.rollback();
    console.error('Error al eliminar evidencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar la evidencia',
      error: error.message
    });
  }
};
