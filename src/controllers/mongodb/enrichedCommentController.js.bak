const { EnrichedComment } = require('../../models/mongodb');
const { User } = require('../../models');
const { createNotification } = require('../notificationController');

/**
 * Crear un nuevo comentario enriquecido
 */
exports.createComment = async (req, res) => {
  try {
    const { entityType, entityId, content, formats, parentId } = req.body;
    // Obtener el ID de usuario de la solicitud o usar un valor predeterminado para pruebas
    // Verificar que el usuario esté autenticado y tenga un ID válido
    if (!req.user || !req.user.id) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no autenticado o ID de usuario inválido'
      });
    }
    const userId = req.user.id;

    // Validar los datos de entrada
    if (!entityType || !entityId || !content) {
      return res.status(400).json({
        success: false,
        message: 'Faltan campos requeridos: entityType, entityId, content'
      });
    }

    // Obtener informaciÃ³n del usuario para incluirla en el comentario
    const user = await User.findByPk(userId, {
      attributes: ['id', 'username', 'fullName', 'profilePicture']
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Verificar si es una respuesta a otro comentario
    let level = 0;
    let parentComment = null;

    if (parentId) {
      parentComment = await EnrichedComment.findById(parentId);
      
      if (!parentComment) {
        return res.status(404).json({
          success: false,
          message: 'Comentario padre no encontrado'
        });
      }

      // Establecer el nivel de anidaciÃ³n
      level = parentComment.level + 1;
      
      // Limitar la profundidad de los hilos
      if (level > 3) {
        return res.status(400).json({
          success: false,
          message: 'Se ha alcanzado el lÃ­mite mÃ¡ximo de anidaciÃ³n de comentarios'
        });
      }
    }

    // Procesar menciones en el contenido
    const mentionMatches = content.match(/@(\w+)/g) || [];
    const mentions = [];

    // Buscar informaciÃ³n de los usuarios mencionados
    for (const mention of mentionMatches) {
      const username = mention.substring(1); // Eliminar el @
      const mentionedUser = await User.findOne({
        where: { username },
        attributes: ['id', 'username']
      });

      if (mentionedUser) {
        const startIndex = content.indexOf(mention);
        mentions.push({
          userId: mentionedUser.id,
          username: mentionedUser.username,
          startIndex,
          endIndex: startIndex + mention.length
        });
      }
    }

    // Crear el comentario enriquecido
    const newComment = new EnrichedComment({
      userId,
      user: {
        username: user.username,
        fullName: user.fullName,
        profilePicture: user.profilePicture
      },
      entityType,
      entityId,
      content,
      formats: formats || [],
      mentions,
      parentId: parentComment ? parentComment._id : null,
      level,
      reactions: {
        like: [],
        love: [],
        haha: [],
        wow: [],
        sad: [],
        angry: [],
        support: []
      },
      replyCount: 0
    });

    await newComment.save();

    // Si es una respuesta, incrementar el contador de respuestas del comentario padre
    if (parentComment) {
      parentComment.replyCount = (parentComment.replyCount || 0) + 1;
      await parentComment.save();
    }

    // Crear notificaciones para las menciones
    for (const mention of mentions) {
      if (mention.userId !== userId) { // No notificar al autor del comentario
        await createNotification({
          type: 'mention',
          recipientId: mention.userId,
          senderId: userId,
          entityId: newComment._id.toString(),
          entityType: 'comment',
          message: `${user.username} te ha mencionado en un comentario`,
          data: {
            commentId: newComment._id.toString(),
            parentEntityType: entityType,
            parentEntityId: entityId,
            content: content.substring(0, 100) + (content.length > 100 ? '...' : '')
          }
        });
      }
    }

    // Si es una respuesta, notificar al autor del comentario padre
    if (parentComment && parentComment.userId !== userId) {
      await createNotification({
        type: 'reply',
        recipientId: parentComment.userId,
        senderId: userId,
        entityId: newComment._id.toString(),
        entityType: 'comment',
        message: `${user.username} ha respondido a tu comentario`,
        data: {
          commentId: newComment._id.toString(),
          parentCommentId: parentComment._id.toString(),
          parentEntityType: entityType,
          parentEntityId: entityId,
          content: content.substring(0, 100) + (content.length > 100 ? '...' : '')
        }
      });
    }

    res.status(201).json({
      success: true,
      data: newComment
    });
  } catch (error) {
    console.error('Error al crear comentario enriquecido:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear comentario enriquecido',
      error: error.message
    });
  }
};

/**
 * Obtener comentarios por entidad
 */
exports.getCommentsByEntity = async (req, res) => {
  try {
    const { entityType, entityId } = req.params;
    const { page = 1, limit = 20, parentId = null } = req.query;

    // Validar los datos de entrada
    if (!entityType || !entityId) {
      return res.status(400).json({
        success: false,
        message: 'Faltan parÃ¡metros requeridos: entityType, entityId'
      });
    }

    const skip = (page - 1) * limit;

    // Construir la consulta base
    const query = {
      entityType,
      entityId,
      isDeleted: false
    };

    // Si parentId es 'null' (como string), buscamos comentarios de nivel superior
    // Si parentId tiene un valor, buscamos respuestas a ese comentario especÃ­fico
    if (parentId === 'null') {
      query.parentId = null;
    } else if (parentId) {
      query.parentId = parentId;
    }

    // Contar el total de comentarios que coinciden con la consulta
    const total = await EnrichedComment.countDocuments(query);

    // Obtener los comentarios paginados
    const comments = await EnrichedComment.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    // Obtener informaciÃ³n de usuario para cada comentario
    const populatedComments = await Promise.all(comments.map(async (comment) => {
      const user = await User.findOne({ where: { id: comment.userId } });
      
      return {
        ...comment.toObject(),
        user: user ? {
          username: user.username,
          fullName: user.fullName,
          profilePicture: user.profilePicture
        } : { username: 'Usuario eliminado' }
      };
    }));

    res.status(200).json({
      success: true,
      data: {
        comments: populatedComments,
        pagination: {
          total,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(total / limit),
          hasMore: skip + comments.length < total
        }
      }
    });
  } catch (error) {
    console.error('Error al obtener comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener comentarios',
      error: error.message
    });
  }
};

/**
 * Obtener un comentario especÃ­fico con sus respuestas
 */
exports.getCommentWithReplies = async (req, res) => {
  try {
    const { commentId } = req.params;
    const { page = 1, limit = 20 } = req.query;

    // Validar los datos de entrada
    if (!commentId) {
      return res.status(400).json({
        success: false,
        message: 'Falta el ID del comentario'
      });
    }

    // Buscar el comentario principal
    const comment = await EnrichedComment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    // Obtener informaciÃ³n del usuario del comentario principal
    const commentUser = await User.findOne({ where: { id: comment.userId } });

    // Buscar respuestas al comentario
    const skip = (page - 1) * limit;
    const repliesQuery = {
      parentId: commentId,
      isDeleted: false
    };

    const replies = await EnrichedComment.find(repliesQuery)
      .sort({ createdAt: 1 })
      .skip(skip)
      .limit(parseInt(limit));

    const totalReplies = await EnrichedComment.countDocuments(repliesQuery);

    // Obtener informaciÃ³n de usuario para cada respuesta
    const populatedReplies = await Promise.all(replies.map(async (reply) => {
      const user = await User.findOne({ where: { id: reply.userId } });
      
      return {
        ...reply.toObject(),
        user: user ? {
          username: user.username,
          fullName: user.fullName,
          profilePicture: user.profilePicture
        } : { username: 'Usuario eliminado' }
      };
    }));

    res.status(200).json({
      success: true,
      data: {
        comment: {
          ...comment.toObject(),
          user: commentUser ? {
            username: commentUser.username,
            fullName: commentUser.fullName,
            profilePicture: commentUser.profilePicture
          } : { username: 'Usuario eliminado' }
        },
        replies: populatedReplies,
        pagination: {
          total: totalReplies,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(totalReplies / limit),
          hasMore: skip + replies.length < totalReplies
        }
      }
    });
  } catch (error) {
    console.error('Error al obtener comentario con respuestas:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener comentario con respuestas',
      error: error.message
    });
  }
};

/**
 * Actualizar un comentario
 */
exports.updateComment = async (req, res) => {
  try {
    const { commentId } = req.params;
    const { content, formats } = req.body;
    // Obtener el ID de usuario de la solicitud o usar un valor predeterminado para pruebas
    // Verificar que el usuario esté autenticado y tenga un ID válido
    if (!req.user || !req.user.id) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no autenticado o ID de usuario inválido'
      });
    }
    const userId = req.user.id;

    // Validar los datos de entrada
    if (!commentId || !content) {
      return res.status(400).json({
        success: false,
        message: 'Faltan campos requeridos: commentId, content'
      });
    }

    // Buscar el comentario
    const comment = await EnrichedComment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    // Verificar que el usuario sea el autor del comentario
    if (comment.userId !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para editar este comentario'
      });
    }

    // Procesar menciones en el contenido actualizado
    const mentionMatches = content.match(/@(\w+)/g) || [];
    const mentions = [];

    // Buscar informaciÃ³n de los usuarios mencionados
    for (const mention of mentionMatches) {
      const username = mention.substring(1); // Eliminar el @
      const mentionedUser = await User.findOne({
        where: { username },
        attributes: ['id', 'username']
      });

      if (mentionedUser) {
        const startIndex = content.indexOf(mention);
        mentions.push({
          userId: mentionedUser.id,
          username: mentionedUser.username,
          startIndex,
          endIndex: startIndex + mention.length
        });
      }
    }

    // Obtener menciones anteriores para comparar
    const previousMentions = comment.mentions || [];
    const previousMentionUserIds = previousMentions.map(m => m.userId);
    const newMentionUserIds = mentions.map(m => m.userId);

    // Encontrar nuevas menciones (usuarios que no estaban mencionados antes)
    const newMentions = mentions.filter(mention => 
      !previousMentionUserIds.includes(mention.userId) && mention.userId !== userId
    );

    // Actualizar el comentario
    comment.content = content;
    comment.formats = formats || [];
    comment.mentions = mentions;
    comment.updatedAt = new Date();

    await comment.save();

    // Obtener informaciÃ³n del usuario para incluirla en la respuesta
    const user = await User.findByPk(userId, {
      attributes: ['id', 'username', 'fullName', 'profilePicture']
    });

    // Crear notificaciones para las nuevas menciones
    for (const mention of newMentions) {
      await createNotification({
        type: 'mention',
        recipientId: mention.userId,
        senderId: userId,
        entityId: comment._id.toString(),
        entityType: 'comment',
        message: `${user.username} te ha mencionado en un comentario editado`,
        data: {
          commentId: comment._id.toString(),
          parentEntityType: comment.entityType,
          parentEntityId: comment.entityId,
          content: content.substring(0, 100) + (content.length > 100 ? '...' : '')
        }
      });
    }

    res.status(200).json({
      success: true,
      data: {
        ...comment.toObject(),
        user: {
          username: user.username,
          fullName: user.fullName,
          profilePicture: user.profilePicture
        }
      }
    });
  } catch (error) {
    console.error('Error al actualizar comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar comentario',
      error: error.message
    });
  }
};

/**
 * Eliminar un comentario (soft delete)
 */
exports.deleteComment = async (req, res) => {
  try {
    const { commentId } = req.params;
    // Obtener el ID de usuario de la solicitud o usar un valor predeterminado para pruebas
    // Verificar que el usuario esté autenticado y tenga un ID válido
    if (!req.user || !req.user.id) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no autenticado o ID de usuario inválido'
      });
    }
    const userId = req.user.id;

    // Validar los datos de entrada
    if (!commentId) {
      return res.status(400).json({
        success: false,
        message: 'Falta el ID del comentario'
      });
    }

    // Buscar el comentario
    const comment = await EnrichedComment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    // Verificar que el usuario sea el autor del comentario o un administrador
    const isAdmin = req.user.role === 'admin';
    if (comment.userId !== userId && !isAdmin) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permiso para eliminar este comentario'
      });
    }

    // Realizar soft delete
    comment.isDeleted = true;
    comment.content = 'Este comentario ha sido eliminado';
    comment.formats = [];
    comment.mentions = [];

    await comment.save();

    // Si el comentario tiene un padre, decrementar su contador de respuestas
    if (comment.parentId) {
      const parentComment = await EnrichedComment.findById(comment.parentId);
      if (parentComment) {
        parentComment.replyCount = Math.max(0, (parentComment.replyCount || 1) - 1);
        await parentComment.save();
      }
    }

    res.status(200).json({
      success: true,
      message: 'Comentario eliminado correctamente'
    });
  } catch (error) {
    console.error('Error al eliminar comentario:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar comentario',
      error: error.message
    });
  }
};

/**
 * Agregar una reacciÃ³n a un comentario
 */
exports.addReaction = async (req, res) => {
  try {
    const { commentId } = req.params;
    const { type } = req.body;
    // Obtener el ID de usuario de la solicitud o usar un valor predeterminado para pruebas
    // Verificar que el usuario esté autenticado y tenga un ID válido
    if (!req.user || !req.user.id) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no autenticado o ID de usuario inválido'
      });
    }
    const userId = req.user.id;

    // Validar los datos de entrada
    if (!commentId || !type) {
      return res.status(400).json({
        success: false,
        message: 'Faltan campos requeridos: commentId, type'
      });
    }

    // Validar el tipo de reacciÃ³n
    const validReactionTypes = ['like', 'love', 'haha', 'wow', 'sad', 'angry', 'support'];
    if (!validReactionTypes.includes(type)) {
      return res.status(400).json({
        success: false,
        message: `Tipo de reacciÃ³n no vÃ¡lido. Debe ser uno de: ${validReactionTypes.join(', ')}`
      });
    }

    // Buscar el comentario
    const comment = await EnrichedComment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    // Inicializar el array de reacciones si no existe
    if (!comment.reactions) {
      comment.reactions = {
        like: [],
        love: [],
        haha: [],
        wow: [],
        sad: [],
        angry: [],
        support: []
      };
    }

    // Eliminar al usuario de todas las reacciones existentes
    Object.keys(comment.reactions).forEach(reactionType => {
      comment.reactions[reactionType] = comment.reactions[reactionType].filter(
        id => id !== userId
      );
    });

    // Agregar la nueva reacciÃ³n
    comment.reactions[type].push(userId);

    await comment.save();

    // Calcular los conteos de reacciones
    const reactionCounts = {};
    Object.keys(comment.reactions).forEach(reactionType => {
      reactionCounts[reactionType] = comment.reactions[reactionType].length;
    });

    // Notificar al autor del comentario si no es el mismo usuario que reacciona
    if (comment.userId !== userId) {
      const user = await User.findByPk(userId, {
        attributes: ['id', 'username', 'fullName']
      });

      await createNotification({
        type: 'reaction',
        recipientId: comment.userId,
        senderId: userId,
        entityId: comment._id.toString(),
        entityType: 'comment',
        message: `A ${user.username} le ${type === 'like' ? 'gusta' : 'ha reaccionado a'} tu comentario`,
        data: {
          commentId: comment._id.toString(),
          reactionType: type,
          parentEntityType: comment.entityType,
          parentEntityId: comment.entityId
        }
      });
    }

    res.status(200).json({
      success: true,
      data: {
        commentId: comment._id,
        reactionCounts,
        userReaction: type
      }
    });
  } catch (error) {
    console.error('Error al agregar reacciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al agregar reacciÃ³n',
      error: error.message
    });
  }
};

/**
 * Eliminar una reacciÃ³n de un comentario
 */
exports.removeReaction = async (req, res) => {
  try {
    const { commentId } = req.params;
    // Obtener el ID de usuario de la solicitud o usar un valor predeterminado para pruebas
    // Verificar que el usuario esté autenticado y tenga un ID válido
    if (!req.user || !req.user.id) {
      return res.status(401).json({
        success: false,
        message: 'Usuario no autenticado o ID de usuario inválido'
      });
    }
    const userId = req.user.id;

    // Validar los datos de entrada
    if (!commentId) {
      return res.status(400).json({
        success: false,
        message: 'Falta el ID del comentario'
      });
    }

    // Buscar el comentario
    const comment = await EnrichedComment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    // Verificar si el usuario ha reaccionado al comentario
    let hasReacted = false;
    if (comment.reactions) {
      Object.keys(comment.reactions).forEach(reactionType => {
        if (comment.reactions[reactionType].includes(userId)) {
          hasReacted = true;
          // Eliminar la reacciÃ³n
          comment.reactions[reactionType] = comment.reactions[reactionType].filter(
            id => id !== userId
          );
        }
      });
    }

    if (!hasReacted) {
      return res.status(400).json({
        success: false,
        message: 'No has reaccionado a este comentario'
      });
    }

    await comment.save();

    // Calcular los conteos de reacciones
    const reactionCounts = {};
    Object.keys(comment.reactions).forEach(reactionType => {
      reactionCounts[reactionType] = comment.reactions[reactionType].length;
    });

    res.status(200).json({
      success: true,
      data: {
        commentId: comment._id,
        reactionCounts,
        userReaction: null
      }
    });
  } catch (error) {
    console.error('Error al eliminar reacciÃ³n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar reacciÃ³n',
      error: error.message
    });
  }
};

/**
 * Buscar comentarios por contenido
 */
exports.searchComments = async (req, res) => {
  try {
    const { query, entityType, entityId } = req.query;
    const { page = 1, limit = 20 } = req.query;

    // Validar los datos de entrada
    if (!query) {
      return res.status(400).json({
        success: false,
        message: 'Falta el parÃ¡metro de bÃºsqueda'
      });
    }

    const skip = (page - 1) * limit;

    // Construir la consulta de bÃºsqueda
    const searchQuery = {
      content: { $regex: query, $options: 'i' },
      isDeleted: false
    };

    // Filtrar por tipo de entidad y ID si se proporcionan
    if (entityType) searchQuery.entityType = entityType;
    if (entityId) searchQuery.entityId = entityId;

    // Contar el total de resultados
    const total = await EnrichedComment.countDocuments(searchQuery);

    // Obtener los comentarios paginados
    const comments = await EnrichedComment.find(searchQuery)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    // Obtener informaciÃ³n de usuario para cada comentario
    const populatedComments = await Promise.all(comments.map(async (comment) => {
      const user = await User.findOne({ where: { id: comment.userId } });
      
      return {
        ...comment.toObject(),
        user: user ? {
          username: user.username,
          fullName: user.fullName,
          profilePicture: user.profilePicture
        } : { username: 'Usuario eliminado' }
      };
    }));

    res.status(200).json({
      success: true,
      data: {
        comments: populatedComments,
        pagination: {
          total,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(total / limit),
          hasMore: skip + comments.length < total
        }
      }
    });
  } catch (error) {
    console.error('Error al buscar comentarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error al buscar comentarios',
      error: error.message
    });
  }
};

/**
 * Obtener las reacciones de un comentario
 */
exports.getReactions = async (req, res) => {
  try {
    const { commentId } = req.params;
    const { type } = req.query;
    
    // Validar los datos de entrada
    if (!commentId) {
      return res.status(400).json({
        success: false,
        message: 'Falta el ID del comentario'
      });
    }

    // Buscar el comentario
    const comment = await EnrichedComment.findById(commentId);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: 'Comentario no encontrado'
      });
    }

    // Si no hay reacciones, devolver objeto vacÃ­o
    if (!comment.reactions) {
      return res.status(200).json({
        success: true,
        data: {
          reactions: {},
          reactionCounts: {
            like: 0,
            love: 0,
            haha: 0,
            wow: 0,
            sad: 0,
            angry: 0,
            support: 0
          }
        }
      });
    }

    // Filtrar por tipo de reacciÃ³n si se especifica
    let reactionData = {};
    if (type && comment.reactions[type]) {
      reactionData[type] = comment.reactions[type];
    } else {
      reactionData = comment.reactions;
    }

    // Calcular conteos de reacciones
    const reactionCounts = {};
    Object.keys(comment.reactions).forEach(reactionType => {
      reactionCounts[reactionType] = comment.reactions[reactionType].length || 0;
    });

    // Obtener informaciÃ³n de los usuarios que reaccionaron (para los primeros 10 de cada tipo)
    const userReactions = {};
    const userIdsToFetch = new Set();
    
    Object.entries(reactionData).forEach(([reactionType, userIds]) => {
      // Tomar solo los primeros 10 usuarios para cada tipo de reacciÃ³n
      const userIdsToProcess = userIds.slice(0, 10);
      userIdsToProcess.forEach(userId => userIdsToFetch.add(userId));
      userReactions[reactionType] = userIdsToProcess;
    });

    // Buscar informaciÃ³n de los usuarios
    const userIds = Array.from(userIdsToFetch);
    let users = [];
    
    if (userIds.length > 0) {
      users = await User.findAll({
        where: { id: userIds },
        attributes: ['id', 'username', 'fullName', 'profilePicture']
      });
    }

    // Crear un mapa de usuarios para fÃ¡cil acceso
    const userMap = {};
    users.forEach(user => {
      userMap[user.id] = {
        id: user.id,
        username: user.username,
        fullName: user.fullName,
        profilePicture: user.profilePicture
      };
    });

    // Mapear las reacciones con la informaciÃ³n de los usuarios
    const reactionsWithUsers = {};
    Object.entries(userReactions).forEach(([reactionType, userIds]) => {
      reactionsWithUsers[reactionType] = userIds.map(userId => ({
        userId,
        user: userMap[userId] || { username: 'Usuario desconocido' }
      }));
    });

    res.status(200).json({
      success: true,
      data: {
        reactions: reactionsWithUsers,
        reactionCounts
      }
    });
  } catch (error) {
    console.error('Error al obtener reacciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener reacciones',
      error: error.message
    });
  }
};
